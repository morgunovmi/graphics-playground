# Кадры в полёте

**Зависимости: [local_shadertoy2](/tasks/local_shadertoy2/)**.

В данном задании нам предстоит научиться ускорять графические приложения потенциально в 2 раза.

## Перед началом

 1. Скопируйте решение задания [локальный Shadertoy 2](/tasks/local_shadertoy2/) в эту папку.
 2. Установите [Tracy profiler](https://github.com/wolfpld/tracy).
 Для Windows распространяется готовый бинарь, но на Linux вам придётся скомпилировать его руками.
 Имейте в виду, что если у вас Ubuntu старее чем 24.04, вам придётся компилировать Tracy со флажком LEGACY, заставив его использовать X11 вместо Wayland.
 3. Вспомните материал с занятий по асинхронности GPU и CPU.

## Задание

#### Шаг 1

Во-первых, чтобы сопоставить таймлайны CPU и GPU, нам придётся расставить немножко марекров Tracy в вашем коде.
Сделайте это по аналогии с семплом [shadowmap](/samples/shadowmap/).
Запустите Tracy и вашу программу, подключите Tracy к ней, запишите некоторое количество кадров и посмотрите внимательно на то, как выглядит трейс.
Какие выводы можно сделать, сопоставив GPU и CPU маркеры?

Чтобы эмулировать более крупной приложение, добавьте и на CPU и на GPU дополнительной "бесполезной" работы, чтобы кадр занимал и на CPU и на GPU чуть больше 16 миллисекунд.
На CPU для этого можно использовать обычный sleep, а на GPU повысьте качестве трассировки SDF.
Ещё раз посмотрите в профайлер и сопоставьте маркеры на CPU и GPU.
Тратим ли мы время в ожидании чего-нибудь?

#### Шаг 2

В коде инициализации Etna поправьте параметр `numFramesInFlight` на 2 или 3.
**Исправьте все ошибки валидации**, получившиеся из-за параллельной работы CPU и GPU.
Ещё раз посмотрите в профайлер.
Что изменилось?

Если вы всё сделали правильно, общая частота кадров приложения должна была вырости, а ошибок валидации, артефактов или крашей быть не должно.

В дальнейших домашках тоже рекомендуется пользоваться Tracy для понимания, какие места являются "узкими" в ваших приложениях.
